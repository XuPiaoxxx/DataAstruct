package CodeFly;

import java.util.Arrays;

/**
 *  最后一块石头的重量 II--LeetCode:1049-代码随想录
 * 2023.10.7/17.58
01背包问题!!!!!!
 转化思路:
 数组中的元素代表价值与重量都等于这个元素值的物品,装入容量为目标值的背包中。

 如果最终结果，返回两部分的差值
 因为sum/2，int向下取整，所以sum-dp[sum/2]一定是两部分之中较大的一部分。
 dp[sum/2]是较小的一部分

 题目:有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。

 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

 如果 x == y，那么两块石头都会被完全粉碎；
 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。

 TIPS:

 严格按照动态规划5步来分析:
 1确定dp数组及对应下标的含义---一维滚动数组，01背包模板，从下标为0到下标为i的数之间进行选择装入容量为目标值的背包中，即：下标为0~i小于目标值的最大价值
 2分析出状态转移方程-背包问题:01背包问题一维滚动数组--dp[j]=max(dp[j],dp[j-重量]+价值)
 3确定dp数组的初始化赋值-当容量为0时，dp[0]=0,不能放任何数字，大小为0，其他初始值随意设置，但是不能影响后面的max判断，所以全部设为0.
 4确定遍历顺序--第一层遍历物品从左到右，第二层遍历背包容量从右到左，必须先遍历物品，再遍历背包容量
 (原因:背包容量从右到左是因为，如果从左到右会覆盖上一层i-1的值，导致i-1层的值被第i层覆盖，这时后面的递归公式会用i层的值，但这是不符合预期的，脑子里时刻有一张二维表格，会导致1个数取用多次。
        第二个原因是:如果先遍历背包容量，内层遍历数字，那么倒序会导致只存入一个最大的数字(因为除了最后一列其他都是0))
 5打印dp数组(没有在线oj，需要判断dp数组是否符合预期) --无所谓
 */

public class L0093LeetCode1049 {
    public static void main(String[] args) {

    }
    public int lastStoneWeightII(int[] stones) {
        int sum=0;
        for(int i:stones){
            sum+=i;
        }
        //将数组分为和尽量接近的两部分，采用01背包算法，背包大小可以为石头数量上限/2。也可以赋值为sum/2+1动态调整；
        int[] dp=new int[sum/2+1];
        for(int i=0;i<stones.length;i++){
            for(int j=sum/2;j>=stones[i];j--){
                dp[j]=Math.max(dp[j],dp[j-stones[i]]+stones[i]);
            }
            //如何把问题转化为01背包并且考虑清楚是我现在最重要的事情
        }
        return sum-dp[sum/2]-dp[sum/2];
        // 如果最终结果，返回两部分的差值
        // 因为sum/2，int向下取整，所以sum-dp[sum/2]一定是两部分之中较大的一部分。
        // dp[sum/2]是较小的一部分
    }
}
