package CodeFly;

/**
 *  买卖股票的最佳时机 III--LeetCode:123-代码随想录
 * 2023.10.12/10.51

 题目:给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 TIPS:
本题限制交易最多能有两次，因此会多出两个状态，其他和前面的题大体类似
 */

public class L00106LeetCode123 {
    public static void main(String[] args) {

    }
    //状态dp动态规划解法:
    //1.dp[i][j]代表了第i天中选择状态j拥有的最大金额，j=0第一次持有股票，j=1第一次不持有持有股票，j=3第二次持有股票,j=4第二次不持有股票
    //2.因为有4个状态，所以维护一个二维数组，每个一维数组长度为4.(实际上还有一个刚开始未持有的状态，但是其取值都是0，可以直接省略，第一次持有直接在0的基础上进行减)
    //需要对四种状态各自设计状态转移方程；
    //第一次持股 ，两种选择
    //第一次不持股,以下同理
    //第二次持股
    //第二次不持股
    //同样取两者中的最大值
    //3.初始化，dp[0][0]为第一次持股，只能为-prices[0],dp[0][1]为第一次不持股，为0，买完就卖，dp[0][2]第二次持股，第一天时可以买完卖再买为-price[0]
    //dp[0][3]为第二次不持有股票，第一天来说就是又卖出了，为0
    //最后返回值本来是取，第一次不持有和第二次不持有的最大值，但是如果第一次不持有利润最高，可以将第二次不持有看成买完又卖，所以相等，总得来说直接返回第二次未持有就可
    //4.因为状态转移中，后一天需要前一天的两种状态的信息，所以按照从左到右，按天进行遍历。

    //5.打印
    //常规动态规划思路
    public int maxProfit(int[] prices) {
        int n=prices.length;
        int[][] dp=new int[n][4];
        dp[0][0]=-prices[0];
        dp[0][1]=0;
        dp[0][2]=-prices[0];
        dp[0][3]=0;
        for(int i=1;i<n;i++){
            dp[i][0]=Math.max(dp[i-1][0],-prices[i]);
            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]+prices[i]);
            dp[i][2]=Math.max(dp[i-1][2],dp[i-1][1]-prices[i]);
            dp[i][3]=Math.max(dp[i-1][3],dp[i-1][2]+prices[i]);
        }
        return dp[n-1][3];
    }
    //空间优化
    //dp[2]利用的是当天的dp[1]。 但结果也是对的。
    //我来简单解释一下：
    //dp[1] = max(dp[1], dp[0] - prices[i]); 如果dp[1]取dp[1]，即保持买入股票的状态，那么 dp[2] = max(dp[2], dp[1] + prices[i]);中dp[1] + prices[i] 就是今天卖出。
    //如果dp[1]取dp[0] - prices[i]，今天买入股票，那么dp[2] = max(dp[2], dp[1] + prices[i]);中的dp[1] + prices[i]相当于是今天再卖出股票，一买一卖收益为0，对所得现金没有影响。相当于今天买入股票又卖出股票，等于没有操作，保持昨天卖出股票的状态了。
    //这种写法看上去简单，其实思路很绕，不建议大家这么写，这么思考，很容易把自己绕进去！
    public int maxProfit1(int[] prices) {
        int[] dp = new int[4];
        // 存储两次交易的状态就行了
        // dp[0]代表第一次交易的买入
        dp[0] = -prices[0];
        // dp[1]代表第一次交易的卖出
        dp[1] = 0;
        // dp[2]代表第二次交易的买入
        dp[2] = -prices[0];
        // dp[3]代表第二次交易的卖出
        dp[3] = 0;
        for(int i = 1; i <= prices.length; i++){
            // 要么保持不变，要么没有就买，有了就卖
            dp[0] = Math.max(dp[0], -prices[i-1]);
            dp[1] = Math.max(dp[1], dp[0]+prices[i-1]);
            // 这已经是第二次交易了，所以得加上前一次交易卖出去的收获
            dp[2] = Math.max(dp[2], dp[1]-prices[i-1]);
            dp[3] = Math.max(dp[3], dp[2]+ prices[i-1]);
        }
        return dp[3];
    }



}
