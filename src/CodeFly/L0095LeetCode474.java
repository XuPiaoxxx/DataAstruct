package CodeFly;

/**
 *  一和零--LeetCode:494-代码随想录
 * 2023.10.8/17.12

 题目:给你一个二进制字符串数组 strs 和两个整数 m 和 n 。
 请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。
 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

 01背包问题!!!!!!
 转化思路:
 按照题目，可以分为重量1和重量2，分别为限制的最大0数量和1数量，其中每个字符串元素看成每个物品，重量也分为1的数量(重量1)，0的数量
 (重量2)
 也可以转换成一个带体积和重量的背包，尽量往里面装，最后求的是背包中的物品数(和前面的题不一样)

 TIPS:

 严格按照动态规划5步来分析:
 1确定dp数组及对应下标的含义---因为有两个条件限制(体积和重量)，所以数组还要再增加一个维度，滚动数组变为二维，但是原理是一样的。含义也类似
    从物品0~i中选择,背包重量上限为m，体积上限为n，尽量装满背包并满足两个条件限制，dp[i][j]为背包中物品的数量

 2分析出状态转移方程-因为要求背包中的物品数量，和前面的又有不同 dp[i][j]=Math.max(dp[i][j],dp[i-重量][j-体积]+1)----如果是三维数组原理和二维滚动数组一样

 3确定dp数组的初始化赋值-当重量上限为0，体积上限为0，一个元素都装不进去，所以dp[0][0]=0，其他位置因为不能影响求每个块的最大值，所以设置为0
 4确定遍历顺序--第一层遍历物品从左到右，第二层遍历背包容量从右到左，第三层是第二个限制条件也是从右到左，后序遍历必须先遍历物品，再遍历背包容量
 (原因:背包容量从右到左是因为，如果从左到右会覆盖上一层i-1的值，导致i-1层的值被第i层覆盖，这时后面的递归公式会用i层的值，但这是不符合预期的，脑子里时刻有一张二维表格，会导致1个数取用多次。
        第二个原因是:如果先遍历背包容量，内层遍历数字，那么倒序会导致只存入一个最大的数字(因为除了最后一列其他都是0))
        转移会用到前面的数，所以倒序遍历数组
 5打印dp数组(没有在线oj，需要判断dp数组是否符合预期) --无所谓
 */

public class L0095LeetCode474 {
    public static void main(String[] args) {

    }
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp=new int[m+1][n+1];
        for(String i:strs){
            int zero=0,one=0;
            for(int c=0;c<i.length();c++){
                if(i.charAt(c)=='0') zero++;
                else one++;
            }
            for(int h1=m;h1>=zero;h1--){
                for(int h2=n;h2>=one;h2--){
                    dp[h1][h2]=Math.max(dp[h1][h2],dp[h1-zero][h2-one]+1);
                }
            }
        }
        return dp[m][n];
    }
}
