package CodeFly;

/**
 *  零钱兑换--LeetCode:322-代码随想录
 * 2023.10.9/21.19

 题目:给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

 你可以认为每种硬币的数量是无限的。

完全背包问题!!!!!!
 转化思路:
 本总结的硬币面额转换为对应数字，背包容量为target
 按照题目，完全背包可以由01背包演化而来，01背包每个物品只有一个，只能用一次，而完全背包的物品有无数个，可以用
 无数次。
 本题target为背包容量。硬币的面值为对应的重量。
 经典的完全背包问题

 TIPS:

 严格按照动态规划5步来分析:
 1确定dp数组及对应下标的含义--从数组中选择下标从0~i的硬币面额考虑加入背包中，dp[j]为背包容量为j时，加入背包中的物品（硬币）数目

 2分析出状态转移方程--求最小的放入的硬币数  dp[j]=Math.min(dp[j],dp[j-coins[i]]+1)


 3确定dp数组的初始化赋值--按照题意，dp[j]为对应容量为j放入的硬币数，所以dp[0]=0,因为对应的状态转移方程要判断最小值，所以不能影响，要设置其他初始值尽量大
 所以初步设为Integer.MAX_VALUE,但是此值+1，会变为对应的最小值，从而影响对后面的判断，最后进行特判时也会摸不着头脑
 所以退而求其次设为容量+1(本题容量最大为10的四次方)

 4确定遍历顺序--完全背包在一维滚动数组中第一层遍历和01背包一样，第二层遍历也需要从左到右，这样才有可能重复使用同一个物品
 (后序只能使用一次)
 在纯完全背包问题中（指求满足背包容量的的最大价值），先遍历背包还是先遍历背包容量没有影响，因为不管是组合还是排列，对于
 最大价值没影响，不同排列都是固定的最大价值。
    按照题目，本题求硬币数目，对于内部的排列顺序无影响，所以遍历顺序没有强制规定

 5打印dp数组(没有在线oj，需要判断dp数组是否符合预期) --无所谓
 */

public class L0098LeetCode322 {
    public static void main(String[] args) {

    }
    public int coinChange(int[] coins, int amount) {
        int[] dp=new int[amount+1];
        for(int i=1;i<dp.length;i++){
            dp[i]=amount+1;
        }
        for(int i=0;i<coins.length;i++){
            for(int j=coins[i];j<=amount;j++){
                dp[j]=Math.min(dp[j],dp[j-coins[i]]+1);
            }
        }
        return dp[amount]==amount+1?-1:dp[amount];
    }
}
