package CodeFly;

/**
 *  不相交的线--LeetCode:1035-代码随想录
 * 2023.10.14/12.30

 题目:在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。

 现在，可以绘制些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：
 nums1[i] == nums2[j]
 且绘制的直线不与任何其他连线（非水平线）相交。
 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。
 以这种方法绘制线条，并返回可以绘制的最大连线数。
 */
//转换看问题的角度，本题和1143最长公共子序列是一道题，只不过对于问题进行了包装，
    //做法完全一样
public class L00114LeetCode1035 {
    public static void main(String[] args) {

    }
    //因为有两个数组，且要找二者的公共部分，所以需要二维的dp数组，来分别确定两个子序列的范围。
    //如果当前遍历的两个数组中的数相同，则在两个数组中相对的以当前数的前一个为结尾的数的最长公共子序列的长度+1(这时候加的那个位置有可能不相等，而这个值是从前面最大
    // 的相等值保留过来的)
    //这样每次都会更新，最大的长度就是dp数组最后一个值
    //状态dp动态规划解法:
    //1.dp[i][j]的含义是，第一个数组中下标0~i和第二个数组下标0~j为结尾的的范围中，最长公共子序列的长度为dp[i][j]
    //2.在nums[i]=nums[j]的条件下，dp[i][j]=dp[i-1][j-1]+1;
    //如果不相等，则选取之前的序列(1.数组1,0~i，数组2,0~j-1)(2.数组1,0~i-1,数组2,，0~j)这两种序列选择的最大值。
    //即dp[i][j]=Math.max(dp[i][j-1],dp[i-1][j])
    //3.初始化,二维数组中多加一行，一列作为第一行和第一列，初始化为0，即数组长度为[nums1.length+1][nums2.length+1]
    //这样初始化更方便
    //这样在状态转移时:dp[i-1][j-1]才代表数组下标i和下标j结尾的子数组
    //4.遍历顺序：纵观dp数组，是从上到下，从左到右，从左上到右下，所以遍历顺序应该是从左到右，从上到下(两个数组无先后)
    //5.打印
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int[][] dp=new int[nums1.length+1][nums2.length+1];
        for(int i=1;i<=nums1.length;i++){
            for(int j=1;j<=nums2.length;j++){
                if(nums1[i-1]==nums2[j-1]) dp[i][j]=dp[i-1][j-1]+1;
                else dp[i][j]=Math.max(dp[i][j-1],dp[i-1][j]);
            }
        }
        return dp[nums1.length][nums2.length];
    }




}
