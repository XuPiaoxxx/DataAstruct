package CodeFly;

/**
 *  完全平方数--LeetCode:279-代码随想录
 * 2023.10.9/22.00

 题目:给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。

 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

完全背包问题!!!!!!
 转化思路:
 按照题目，完全背包可以由01背包演化而来，01背包每个物品只有一个，只能用一次，而完全背包的物品有无数个，可以用
 无数次。
 经典的完全背包问题-跟普通完全背包的区别是其中的物品数组需要自己解决(1,2的平方，3的平方。。。循环)直到平方数大于n时，以后的平方数都放不下，所以这是循环上限

 TIPS:

 严格按照动态规划5步来分析:
 1确定dp数组及对应下标的含义--从数组中选择下标从0~i的硬币面额考虑加入背包中，dp[j]为背包容量为j时，加入背包中的物品（平方数）数目
 2分析出状态转移方程--求最小的放入的硬币数  dp[j]=Math.min(dp[j],dp[j-i*i]+1)


 3确定dp数组的初始化赋值--按照题意，dp[j]为对应容量为j放入的硬币数，所以dp[0]=0,因为对应的状态转移方程要判断最小值，所以不能影响，要设置其他初始值尽量大
 所以初步设为Integer.MAX_VALUE,但是此值+1，会变为对应的最小值，从而影响对后面的判断，最后进行特判时也会摸不着头脑
 所以退而求其次设为容量即可(本题容量最大为10的四次方)
 因为1也是平方数，一个数最差的结果就是n个1，所以初始化为n返回更方便

 4确定遍历顺序--完全背包在一维滚动数组中第一层遍历和01背包一样，第二层遍历也需要从左到右，这样才有可能重复使用同一个物品
 (后序只能使用一次)
 在纯完全背包问题中（指求满足背包容量的的最大价值），先遍历背包还是先遍历背包容量没有影响，因为不管是组合还是排列，对于
 最大价值没影响，不同排列都是固定的最大价值。
    按照题目，本题求硬币数目，对于内部的排列顺序无影响，所以遍历顺序没有强制规定

 5打印dp数组(没有在线oj，需要判断dp数组是否符合预期) --无所谓
 */

public class L0099LeetCode279 {
    public static void main(String[] args) {

    }
    public int numSquares(int n) {
        int[] dp=new int[n+1];
        for(int i=0;i<dp.length;i++){
            dp[i]=n;
        }
        dp[0]=0;
        for(int i=0;i*i<=n;i++){
            for(int j=i*i;j<=n;j++){
                dp[j]=Math.min(dp[j],dp[j-i*i]+1);
            }
        }
        return dp[n];
    }
}
